//! **amafatt - processes the data from Amazon txt file and send an api json request to FattureInCloud.it**  
//region: description
//! [comment]: # (lmake_readme insert start)
//!
//! //! [comment]: # ( spellcheck-language "it" )
//!
//! # amafatt
//! Una applicazione prototipo per inserire dati ricevuti da Amazon in formato txt nella API di FattureInCloud.it.  
//! Max sa cosa vuole dalla applicazione ed io (Luciano) costruirò la app come prototipo.  
//! Dopo si vedrà se saremmo contenti con il risultato e si andrà avanti.  
//! ## FattureInCloud.it
//! Ho creato un nuovo account per luciano.bestia@gmail.com dove si può sperimentare.  
//! Io e Max abbiamo accesso a questo account e possiamo collaborare.  
//! La documentazione della API e qui:  
//! https://api.FattureInCloud.it/v1/documentation/dist/#!/Richiesta_generica/JSONRequest  
//! La prima cosa da chiarire sono le liste di prodotti e clienti.  
//! ## Rust, Wasm, Dodrio
//! La lingua nella quale e scritta la applicazione non e molto importante.  
//! Questa si può cambiare anche dopo. La logica della applicazione ed il mapping di dati e importante.  
//! Io costruirò il prototipo nella lingua Rust. La applicazione sarà compilata in Wasm/WebAssembly
//! e funzionerà dentro il browser (Chrome).
//! Per la interfaccia utente GUI userò la library
//! Dodrio Virtual Dom. Per adesso ci sarà molto HTML e niente o pochissimo css e JavaScript.  
//! La lingua di tutti i programmatori e l'Inglese e per questo ci sarà tanto inglese nella source code.  
//!
//! [comment]: # ( spellcheck-language "en" )
//!
//! ## Development environment
//! Install the rust toolchain from  
//! https://www.rust-lang.org/tools/install.  
//! For wasm workflow tool installation on Windows:  
//! https://rustwasm.github.io/wasm-pack/installer/  
//! You will need also a simple static file server:  
//! `cargo install basic-http-server`  
//! ## Source
//! Absolutely everything manually coded is in Rust language in the file `/src/lib.rs`.  
//! No manual JavaScript or HTML needed.  
//! The index.html file is a standard scaffold.  
//! The pkg/mem.js file is generated by wasm-bindgen.  
//! I prepared a small simple css with css grid for styling.   
//! No need for npm or web-pack.  
//! ## Make
//! I will prepare different tasks/flows in cargo make.  
//! https://github.com/sagiegurari/cargo-make  
//! Install it simply with `cargo install --force cargo-make`  
//! `cargo make` - lists the possible available/public flows/tasks  
//! `cargo make dev` - builds the development version and runs the server and the browser  
//! `cargo make release` - builds the release version and runs the server and the browser  
//! The make script will also lunches the `basic-http-server`and open the browser.  
//! ## Workflow
//! The first screen has a big text field where to copy/paste the txt file from Amazon.  
//! No file uploads here because we don't really need/have a server.  
//! The button Next process the txt and creates a json string as close as possible what the API needs.  
//! Next screen shows that json data and it is possible to manually edit what needed.  
//! The button `Send to API` makes a json webrequest to the API.  
//! The next screen shows the respbody of the server.  
//! After that all needed editing, deleting, changing is made through the FattureInCloud.it user interface.  
//! ## TODO
//! - working with structs and vectors is the right way, but it is so much typing and retyping of datatypes and input fields - for small benefit. I will use whole json as a string. And there replace what should be replaced.  
//! - Chrome and Firefox has this Cross-Origin safety, that stops me from doing normal things like a Fetch from other origin. So limiting. There is a good solution. To put a special header in the webresponse: `Access-Control-Allow-Origin: *`. I wrote to FattureInCloud.it, to add it in the header of the webresponse. But you know how are programmers, they will do everything else but not what you need. The workaround is to put a man in the middle. A website that gets the webresponse and adds the missing header.  
//! - fetch api is al about futures and promises, closures and JsValue (so confusing), so I isolated and encapsulated them in a separate module.  
//! - the return of the server is json, but I will work with it for now as a simple string.  
//! ## Reference
//! https://github.com/rustwasm/wasm-bindgen/tree/master/examples/fetch  
//!
//! ## Complains of the old man
//! For a simple fetch api I had to jump over hoops that are not to underestimate.  
//! JsValue, Promises, Futures, Closures, reference to functions, lifetimes,...  
//! I probably did not write them all. Feeling like an absolute beginner. Feeling young again.  
//! [comment]: # (lmake_readme insert end)
//!
//!Firefox understand NoCors and works.
//! Chrome is very limiting with his CORB and does not understand NoCors.
//! the API FattureInCloud.it should return a header with Access-Control-Allow-Origin, but it doesn't.
//! Corb and cors can return a webResponse with no error whatsoever, but it is completely empty.
//! This is very difficult to debug.
//! Neither in Firefox it does not work.
//! As always we need a workaround. A man in the middle to add the header.

//endregion

//region: Clippy
#![warn(
    clippy::all,
    clippy::restriction,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo,
    //variable shadowing is idiomatic to Rust, but unnatural to me.
    clippy::shadow_reuse,
    clippy::shadow_same,
    clippy::shadow_unrelated,

)]
#![allow(
    //library from dependencies have this clippy warnings. Not my code.
    //Why is this bad: It will be more difficult for users to discover the purpose of the crate, 
    //and key information related to it.
    clippy::cargo_common_metadata,
    //Why is this bad : This bloats the size of targets, and can lead to confusing error messages when 
    //structs or traits are used interchangeably between different versions of a crate.
    clippy::multiple_crate_versions,
    //Why is this bad : As the edition guide says, it is highly unlikely that you work with any possible 
    //version of your dependency, and wildcard dependencies would cause unnecessary 
    //breakage in the ecosystem.
    clippy::wildcard_dependencies,
    //Rust is more idiomatic without return statement
    //Why is this bad : Actually omitting the return keyword is idiomatic Rust code. 
    //Programmers coming from other languages might prefer the expressiveness of return. 
    //It’s possible to miss the last returning statement because the only difference 
    //is a missing ;. Especially in bigger code with multiple return paths having a 
    //return keyword makes it easier to find the corresponding statements.
    clippy::implicit_return,
    //I have private function inside a function. Self does not work there.
    //Why is this bad: Unnecessary repetition. Mixed use of Self and struct name feels inconsistent.
    clippy::use_self,
    //Cannot add #[inline] to the start function with #[wasm_bindgen(start)]
    //because then wasm-pack build --target web returns an error: export run not found 
    //Why is this bad: In general, it is not. Functions can be inlined across crates when that’s profitable 
    //as long as any form of LTO is used. When LTO is disabled, functions that are not #[inline] 
    //cannot be inlined across crates. Certain types of crates might intend for most of the 
    //methods in their public API to be able to be inlined across crates even when LTO is disabled. 
    //For these types of crates, enabling this lint might make sense. It allows the crate to 
    //require all exported methods to be #[inline] by default, and then opt out for specific 
    //methods where this might not make sense.
    clippy::missing_inline_in_public_items,
    //Why is this bad: This is only checked against overflow in debug builds. In some applications one wants explicitly checked, wrapping or saturating arithmetic.
    //clippy::integer_arithmetic,
    //Why is this bad: For some embedded systems or kernel development, it can be useful to rule out floating-point numbers.
    clippy::float_arithmetic,
    //Why is this bad : Doc is good. rustc has a MISSING_DOCS allowed-by-default lint for public members, but has no way to enforce documentation of private items. This lint fixes that.
    clippy::doc_markdown,
    //Why is this bad : Splitting the implementation of a type makes the code harder to navigate.
    clippy::multiple_inherent_impl,

    clippy::missing_docs_in_private_items,
)]
//endregion

//region: extern and use statements
//needed for dodrio! macro (typed-html)
#![recursion_limit = "5012"]
//rust modules system
mod fetchmod;
mod reqbodymod;
mod rootrenderingmod;
mod amazonmod;
mod isocountriesmod;
mod credentialsmod;

extern crate console_error_panic_hook;
extern crate log;
extern crate serde;
//#[macro_use]
extern crate serde_derive;
extern crate serde_json;
extern crate web_sys;
#[macro_use]
extern crate unwrap;
extern crate wasm_bindgen_futures;

use wasm_bindgen::prelude::wasm_bindgen;
use web_sys::{console};
use wasm_bindgen::JsValue;
//endregion

///this is the start function that wasm_bindgen calls
#[wasm_bindgen(start)]
pub fn wasm_bindgen_start() {
    // Initialize debugging for when/if something goes wrong.
    console_error_panic_hook::set_once();

    // Get the div for rendering html inside
    let window = unwrap!(web_sys::window());
    let document = unwrap!(window.document());
    let div_for_virtual_dom = unwrap!(
        document.get_element_by_id("div_for_virtual_dom"),
        "No #div_for_virtual_dom"
    );

    // Construct a new rendering component.
    let rrc = rootrenderingmod::RootRenderingComponent::new();

    // Mount the component to the div
    let vdom = dodrio::Vdom::new(&div_for_virtual_dom, rrc);

    // Run the component forever. Never drop the memory. Practically a memory leak.
    vdom.forget();
}

//region: Helper functions
///simple console write with a string
fn log1(x: &str) {
    console::log_1(&JsValue::from_str(x));
}
//endregion